
This is ubf-jsonrpc, a framework for integrating UBF, JSF and
JSON-RPC.  This repository depends on the ubf, gmt-util, and mochiweb
open source repositories.


To download
===========

1. Get and install Git
   http://git-scm.com/

  and then append the following lines to your ~/.gitconfig file:

    [url "git://github.com/norton/gmt-bom.git"]
         insteadOf = git://github.com/norton/src/erl-tools/gmt-bom.git
    [url "git://github.com/norton/ubf.git"]
         insteadOf = git://github.com/norton/src/erl-tools/ubf.git
    [url "git://github.com/norton/ubf-jsonrpc.git"]
         insteadOf = git://github.com/norton/src/erl-tools/ubf-jsonrpc.git
    [url "git://github.com/norton/gmt-util.git"]
         insteadOf = git://github.com/norton/src/erl-apps/gmt-util.git
    [url "git://github.com/norton/mochiweb.git"]
         insteadOf = git://github.com/norton/src/erl-third-party/mochiweb.git

  NOTE: UBF requires git version 1.7.x or newer.  UBF has been tested
  most recently with git version 1.7.1.1.

2. Download the 'bom.sh' tool and then download UBF

    $ mkdir -p ~/work/ubf-jsonrpc
    $ cd ~/work/ubf-jsonrpc
    $ git clone git://github.com/norton/bom.git .
    $ env BOM_GIT=git://github.com/norton/ \
      ./bom.sh co src/erl-tools/ubf-jsonrpc

  NOTE: The Bill of Materials (BOM) system is a way to manage the
  builds of heterougeneous products with shared components using GIT,
  GIT-SVN, SVN, or CVS.  BOM maintains hierarchical dependencies
  between modules stored in a source code repository.  BOM is
  implemented using bash, make, and other UNIX tools.

  NOTE: The bom.sh commands 'diff' and 'status' can be used to check
  the differences and status of all components, respectively.  Type
  './bom.sh help' for further information.

  NOTE: The BOM system was originally developed by Gemini Mobile
  Technologies as an in-house tool to build and to package it's own
  commercial products.  BOM as been open-sourced as one of the helper
  tools for UBF.


To build - basic recipe
=======================

1. Get and install an erlang system
   http://www.erlang.org

   NOTE: UBF requires Erlang/OTP R13B01 or newer.  UBF has been tested
   most recently with Erlang/OTP R13B04.

2. Change to your working directory and create the toplevel Makefile
   $ cd ~/work/ubf-jsonrpc
   $ ./bom.sh make

3. Build UBF
   $ make ERL=/usr/local/hibari/ert/R13B04/bin/erl
     OR
   $ make ERL=/usr/local/hibari/ert/R13B04/bin/erl DEBUG="+debug_info"

   NOTE: Please specify the path to your erlang system's erl
   executable.

   NOTE: DEBUG="+debug_info" will produce DEBUG enabled beam files.

4. Run the unit tests
   $ make ERL=/usr/local/hibari/ert/R13B04/bin/erl test


To build - optional features
============================

A. Run unit test for one module.

   $ make ERL=/usr/local/hibari/ert/R13B04/bin/erl \
     DEBUG="+debug_info" \
     -C src/erl-tools/ubf-jsonrpc__HEAD/src check

B. Clean one module

   $ make ERL=/usr/local/hibari/ert/R13B04/bin/erl \
     DEBUG="+debug_info" \
     -C src/erl-tools/ubf-jsonrpc__HEAD/src clean

C. Rebuild one module

   $ make ERL=/usr/local/hibari/ert/R13B04/bin/erl \
     DEBUG="+debug_info" \
     -C src/erl-tools/ubf-jsonrpc__HEAD/src

D. Generate EDocs for one module

   $ make ERL=/usr/local/hibari/ert/R13B04/bin/erl \
     DEBUG="+debug_info" \
     -C src/erl-tools/ubf-jsonrpc__HEAD/src edoc

E. Run dialyzer for one module (and it dependencies)

   $ make ERL=/usr/local/hibari/ert/R13B04/bin/erl \
     DEBUG="+debug_info" \
     -C src/erl-tools/ubf-jsonrpc__HEAD/src run-dialyzer

   NOTE: Dialyzer will not work unless all beam files have been
   compiled with debug information.
   
   
Documentation -- Where should I start?
======================================

This README is a good first step.  Check out and build using the "To
build" instructions above.

Eunit tests can be found in the Unit-EUnit-Files directory.  These
tests illustrate an inets-based httpd module that uses UBF's contract
manager for checking JSON-RPC requests and responses.


What is UBF?
============

UBF is the "Universal Binary Format", designed and implemented by Joe
Armstrong.  See http://www.sics.se/~joe/ubf.html for full details.  A
really short summary:

   * UBF(A) is a protocol above a stream transport (e.g. TCP/IP), for
     encoding structured dataroughly equivalent to well-formed XML.

   * UBF(B) is a programming langauge for describing types in UBF(A)
     and protocols between clients and servers. UBF(B) is roughly
     equivalent to to Verified XML, XML-schemas, SOAP and WDSL.

     
What is JSF?
============

JSF is an implementation of UBF(B) but does not use UBF(A) for
client<->server communication.  Instead, JSON (RFC 4627) is used.

"JSF" is short for "JavaScript Format".

There is no agreed-upon convention for converting Erlang terms to JSON
objects.  This library uses the convention set forth by MochiWeb's
JSON library (see URL above).  In addition, there are a couple of
other conventions layered on top of MochiWeb's implementation.

   The UBF(B) contract checker has been modified to make a distinction
   between an Erlang record and an arbitrary Erlang tuple.  An
   experience Erlang developer would view such a distinction either
   with skepticism or with approval.

   For the skeptics, the contract author has the option of having the
   UBF(B) contract compiler automatically generate Erlang -record()
   definitions for appropriate tuples within the contract.  Such
   record definitions are very convenient for developers on the Erlang
   side of the world, but they introduce more complication to the
   JavaScript side of the world.  For example, JavaScript does not
   have a concept of an arbitrary atom, as Erlang does.  Also, the
   JavaScript side must make a distinction between {foo, 42} and {bar,
   42} when #foo is a record on the Erlang side but #bar is not.

This extra convention creates something slightly messy-looking, if you
look at the raw JSON passed back-and-forth.  The examples of the
Erlang record {foo, 42} and the general tuple {bar, 42} would look
like this:

   record (defined in the contract as "foo() = #foo{attribute1 = term()};")

      {"$R":"foo", "attribute1":42}

   general tuple

      {"$T":[{"$A":"bar"}, 42]}

However, it requires very little JavaScript code to convert objects
with the "$R", "$T", and "$A" notation (for records, tuples, and
atoms) into whatever object is most convenient.


NOTE: Gemini Mobile Technologies, Inc. has implemented a module for
classifying the input character set to detect non-UTF8 JSON inputs.
This module has not yet been released to the open-source world.
Hence, this application assumes all JSON inputs are valid UTF8.


What is JSON-RPC?
=================

JSON-RPC is a remote procedure call protocol encoded in JSON.  See
http://json-rpc.org/ for full details.


Credits
=======

Many, many thanks to Joe Armstrong, UBF's designer and original
implementor.

Thanks to MochiWeb.  UBF-JSONRPC relies on the MochiWeb
(i.e. mochijson2.erl) application for encoding and decoding JSON in
erlang.

Gemini Mobile Technologies, Inc. has approved the release of this
repository under an MIT license.
